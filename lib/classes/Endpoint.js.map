{"version":3,"file":"Endpoint.js","sources":["../../src/classes/Endpoint.ts"],"sourcesContent":["import {\n    CallMessage,\n    RemoteMethodsMessage,\n    GetProvidedMethodsMessage,\n    MethodsMap,\n} from '../types.js';\nimport { AnyFn } from '../utils/index.js';\nimport { Namespace } from './Namespace.js';\nimport { ReactiveValue } from './ReactiveValue.js';\nimport { EndpointListSet } from './EndpointListSet.js';\nimport { EndpointList } from './EndpointList.js';\n\nexport type Channel = {\n    type: string;\n    send: AnyFn;\n};\n\nexport type Packet = CallMessage | RemoteMethodsMessage | GetProvidedMethodsMessage;\n\nexport class Endpoint<TNamespace extends Namespace> {\n    id: string | null;\n    namespaces: {\n        [key: string]: TNamespace;\n    };\n    get namespaceClass() {\n        return Namespace;\n    }\n    type = 'Endpoint';\n    channels: Channel[] = [];\n    connected = new ReactiveValue(false);\n    remoteEndpoints = new EndpointListSet();\n\n    providedMethodsUpdateTimer?: number | NodeJS.Timeout | null;\n\n    constructor(id?: string) {\n        this.id = id || null;\n        this.namespaces = Object.create(null);\n\n        this.remoteEndpoints.on((endpoints) => {\n            // Star is used as a hack for subscriber<->sandbox communication\n            // TODO: find a better solution\n            this.connected.set(endpoints.includes(this.id || '*'));\n        }, this);\n\n        // TODO: rework\n        // const defaultNS = this.ns('*');\n        // const methodNames: (keyof TNamespace)[] = [];\n\n        // for (\n        //     let cursor = defaultNS;\n        //     cursor && cursor != Object.prototype;\n        //     cursor = Object.getPrototypeOf(cursor)\n        // ) {\n        //     methodNames.push(...(Object.getOwnPropertyNames(cursor) as (keyof TNamespace)[]));\n        // }\n\n        // for (const method of methodNames) {\n        //     // todo rework in the next version\n        //     if (typeof defaultNS[method] === 'function') {\n        //         // @ts-ignore\n        //         this[method] = defaultNS[method].bind(defaultNS);\n        //     }\n        // }\n    }\n\n    getName() {\n        return this.type + (this.id ? '#' + this.id : '');\n    }\n\n    ns<K extends string>(name: K) {\n        let namespace = this.namespaces[name];\n\n        if (!namespace) {\n            namespace = Object.assign(new this.namespaceClass(name, this) as TNamespace);\n            this.namespaces[name] = namespace;\n        }\n\n        return namespace;\n    }\n\n    send<T = Packet>(packet: T, callback: ((...args: unknown[]) => void) | null = null): void {\n        for (const { send } of this.channels) {\n            send(packet, callback);\n        }\n    }\n\n    requestRemoteApi() {\n        this.send({ type: 'getProvidedMethods' } as const, (methods) => {\n            this.setRemoteApi(methods as MethodsMap);\n        });\n    }\n\n    setRemoteApi(api?: MethodsMap) {\n        const changed = [];\n\n        if (!api) {\n            api = {};\n        }\n\n        for (const name in api) {\n            if (Array.isArray(api[name])) {\n                const ns = this.ns(name);\n                const methods = api[name].slice().sort();\n                const different =\n                    ns.remoteMethods.length !== methods.length ||\n                    ns.remoteMethods.some(function (value, idx) {\n                        return value !== methods[idx];\n                    });\n\n                if (different) {\n                    ns.remoteMethods = methods;\n                    changed.push(ns);\n                }\n            }\n        }\n\n        for (const name in this.namespaces) {\n            if (Array.isArray(api[name]) === false) {\n                const ns = this.namespaces[name];\n\n                ns.remoteMethods = [];\n                changed.push(ns);\n            }\n        }\n\n        changed.forEach((ns) => Namespace.notifyRemoteMethodsChanged(ns));\n    }\n\n    getProvidedApi() {\n        const api: MethodsMap = Object.create(null);\n\n        for (const name in this.namespaces) {\n            api[name] = Object.keys(this.namespaces[name].methods).sort();\n        }\n\n        return api;\n    }\n\n    scheduleProvidedMethodsUpdate() {\n        if (!this.providedMethodsUpdateTimer) {\n            this.providedMethodsUpdateTimer = setTimeout(() => {\n                this.providedMethodsUpdateTimer = null;\n                this.send({\n                    type: 'remoteMethods',\n                    methods: this.getProvidedApi(),\n                });\n            }, 0);\n        }\n    }\n\n    processInput(packet: Packet, callback: AnyFn) {\n        switch (packet.type) {\n            case 'call': {\n                const thePacket = packet;\n                const ns = this.ns(thePacket.ns || '*');\n\n                if (!ns.isMethodProvided(thePacket.method)) {\n                    return console.warn(\n                        `[rempl][sync] ${this.getName()} (namespace: ${\n                            thePacket.ns || 'default'\n                        }) has no remote method:`,\n                        thePacket.method\n                    );\n                }\n\n                Namespace.invoke(ns, thePacket.method, thePacket.args, callback);\n                break;\n            }\n\n            case 'remoteMethods': {\n                const thePacket = packet;\n                this.setRemoteApi(thePacket.methods);\n                break;\n            }\n\n            case 'getProvidedMethods':\n                callback(this.getProvidedApi());\n                break;\n\n            default:\n                console.warn(\n                    '[rempl][sync] ' + this.getName() + 'Unknown packet type:',\n                    // @ts-ignore\n                    packet.type\n                );\n        }\n    }\n\n    setupChannel(type: string, send: AnyFn, remoteEndpoints: EndpointList, available: boolean) {\n        if (available) {\n            this.channels.push({\n                type,\n                send,\n            });\n            // Note that endpoints should be changed after channels is changed,\n            // since it may change this.connected that can send something to remote side\n            // when connection is established\n            this.remoteEndpoints.add(remoteEndpoints);\n        } else {\n            for (let i = 0; i < this.channels.length; i++) {\n                if (this.channels[i].type === type && this.channels[i].send === send) {\n                    this.remoteEndpoints.remove(remoteEndpoints);\n                    this.channels.splice(i, 1);\n                    break;\n                }\n            }\n        }\n    }\n}\n"],"names":[],"mappings":"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"}